#Немного теории:

##ключи gcc:
`-m80387` - заставляет компилятор генерировать инструкции для операций с плавающей запятой
`-mno-80387` - заставляет компилятор генерировать инструкции, использующие библиотечные вызовы для операций с плавающей запятой
`-mno-sse` - запрещаем компилятору использовать регистры XMM/MMX и инструкции SSE
Основное отличие между набором инструкций x87 (набор инструкций, предназначенных для использования сопроцессором (FPU - Floating-Point Unit) с процессорами архитектуры x86) и SSE (Streaming SIMD Extensions) заключается в том, что SSE предназначен для параллельной обработки нескольких значений с плавающей запятой в регистрах xmm, что делает его более эффективным для работы с векторными вычислениями и обработки сразу нескольких чисел. Однако x87 все еще используется в некоторых сценариях, особенно в тех случаях, когда требуется поддержка старых архитектур или когда необходимо сохранить совместимость с предыдущими версиями кода.


SSE (англ. Streaming SIMD Extensions, потоковое SIMD-расширение процессора) — это SIMD (англ. Single Instruction, Multiple Data, Одна инструкция — множество данных) набор инструкций, разработанный Intel, и впервые представленный в процессорах серии Pentium III как ответ на аналогичный набор инструкций 3DNow! от AMD, который был представлен годом раньше. Первоначально названим этих инструкций было KNI что расшифровывалось как Katmai New Instructions (Katmai — название первой версии ядра процессора Pentium III).
SSE включает в архитектуру процессора восемь 128-битных регистров (xmm0 до xmm7), каждый из которых трактуется как 4 последовательных значения с плавающей точкой одинарной точности. SSE включает в себя набор инструкций, который производит операции со скалярными и упакованными типами данных.
Преимущество в производительности достигается в том случае, когда необходимо произвести одну и ту же последовательность действий над разными данными.
Реализация блоков SIMD осуществляется распараллеливанием вычислительного процесса между данными. То есть когда через один блок проходит поочерёдно множество потоков данных.
+ Параллельные операции, как правило, действуют одновременно на все четыре 32-разрядных элемента данных в каждом из 128-разрядных операндов. В именах команд, выполняющих параллельные операции, присутствует суффикс PS.
+ Скалярные операции действуют на младшие (занимающие разряды 0-31) элементы данных двух операндов. Остальные три элемента данных в выходном операнде не изменяются (исключение составляет команда скалярного копирования MOVSS). В имени команд, выполняющих скалярные операции, присутствует суффикс SS.


##клёвый документ с командами FPU (Floating-Point Unit):
https://linasm.sourceforge.net/docs/instructions/fpu.php

##клёвый документ с командами SSE1 и в общем про SSE (Streaming SIMD Extensions):
https://studfile.net/preview/1402554/#2

##клёвый документ с командами SSE3 (Streaming SIMD Extensions):
https://www.ixbt.com/cpu/sse3.shtml


##конкретно у меня что:

+ movups xmm0, memory_32 - команда копирует четыре FP-элемента (из памяти в регистр в данном случае). Команда применяется для обращения к невыровненным данным в памяти (у меня они вроде как выровнены, но зачем рисковать, верно?:)).

+ mulps xmm0, xmm1 - команда попарно перемножает упакованные элементы. Произведения записываются в соответствующие элементы XMM-регистра (xmm0)

+ haddps xmm0, xmm0 - осуществляет горизонтальное сложение элементов с одинарной точностью. Первый элемент, записываемый в операнд назначения, является суммой первого и второго элементов первого (исходного) операнда; второй элемент — суммой третьего и четвертого элементов первого операнда; третий элемент — суммой первого и второго элементов второго операнда (операнда назначения) и, наконец, четвертый элемент — суммой третьего и четвертого элементов второго операнда. Для наглядности изобразим это в виде схемы:
Операнд A (128 бит, 4 элемента): a3 | a2 | a1 | a0
Операнд B (128 бит, 4 элемента): b3 | b2 | b1 | b0
HADDPS A, B
Результат (операнд A): b2+b3 | b0+b1 | a2+a3 | a0+a1
у меня: Результат (xmm0): xmm0[2]+xmm0[3] | xmm0[0]+xmm0[1] | xmm0[2]+xmm0[3] | xmm0[0]+xmm0[1]
после второго применения во всех 4 ячейках будет одна сумма всех 4: (xmm0[0]+xmm0[1]+xmm0[2]+xmm0[3])

+ movss memory_32, xmm0 -  команда копирует один 32-рарядный FP-элемент (1 младшую ячейку)